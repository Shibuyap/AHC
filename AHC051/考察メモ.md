# AHC051 考察メモ

## 問題の本質
- 確率的な分別器を組み合わせて、各ごみを正しい処理装置に導く確率を最大化
- 分別器は2分岐のみ → 複数段の分別で精度向上を図る必要がある
- ベルトコンベアの交差制約とDAG制約を満たしながら最適な経路を構築

## 重要な観察
### 1. 分別の基本戦略
- 1つの分別器で完全に分別することは不可能（確率的なため）
- 同じ分別器を複数回通すことで、特定のごみの純度を上げられる
- 異なる分別器を組み合わせることで、より細かい分類が可能

### 2. 確率の計算
- ごみiが処理装置jに到達する確率は、経路上の分別確率の積
- 複数経路がある場合は、各経路の確率の和
- 例：分別器を2段通る場合
  - 1段目で出口1(確率p1) → 2段目で出口1(確率p2) → 最終確率 p1×p2

### 3. グラフ構造の制約
- DAG（有向非循環グラフ）である必要 → トポロジカルソート可能
- ベルトコンベアの交差不可 → 平面グラフ的な制約
- これらの制約により、単純な木構造が有効な可能性

## アプローチ案

### アプローチ1: 決定木的構造
- 二分木のような構造で段階的に分別
- 各段階で最も効果的な分別器を選択
- メリット：シンプル、交差しにくい
- デメリット：分別回数が限られる

### アプローチ2: 特定ごみ専用ライン
- 分別確率が極端に高い組み合わせを見つける
- 特定のごみだけを高確率で分離するラインを構築
- 残りのごみは別ラインで処理

### アプローチ3: 多段フィルタリング
- 同じ分別器を複数回使用
- 徐々に純度を上げていく
- 最終的に高純度のごみを処理装置へ

## 実装方針

### Phase 1: 基本実装
1. 入力の読み込み
2. シンプルな木構造での分別実装
3. 確率計算とスコア算出
4. 出力形式の確認

### Phase 2: 最適化
1. 分別器の選択アルゴリズム
   - 各分別器の「分離度」を評価
   - エントロピーや情報利得で評価
2. 配置の最適化
   - ベルトコンベアが交差しない配置
   - 距離を考慮した配置

### Phase 3: 高度な最適化
1. 動的計画法での経路最適化
2. 焼きなまし法での全体構造の改善
3. ビームサーチでの段階的構築

## 評価指標の分析
- スコア = 10^9 × (1/N) × Σ(1-q[i])
- q[i]を1に近づけることが重要
- 全てのごみを均等に改善するより、改善しやすいものから確実に

## 実装上の注意点
1. 線分交差判定は提供された疑似コードを使用
2. 浮動小数点の精度に注意（確率計算）
3. DAG制約のチェック（トポロジカルソート可能性）
4. メモリと実行時間の制約（2秒、1024MB）

## デバッグ・可視化
- 構築したグラフ構造の可視化
- 各ごみの経路と到達確率の表示
- ベルトコンベアの交差チェック
- スコアの段階的な改善状況の記録

## 分別器を最大限使用するグラフ構築方法

### 基本戦略：完全二分木構造
- N個の処理装置に対して、完全二分木を構築
- 木の高さ h = ceil(log2(N))
- 各レベルで必要な分別器数を配置
- 最下段の葉ノードを処理装置に割り当て

### 構造の特徴
1. **レベル別配置**
   - 各レベルの分別器をy座標で分離（交差回避）
   - x座標は左から右へ順番に配置
   - レベルi: y = 5000 - i * 1000（搬入口から下へ）

2. **ノード数の計算**
   - レベル0（搬入口）: 1ノード
   - レベル1: 1個の分別器
   - レベル2: 2個の分別器
   - レベル3: 4個の分別器
   - ...
   - レベルh: 2^(h-1)個の分別器（最大）
   - 最終的にN個の処理装置へ接続

3. **余剰ノードの処理**
   - 2^h > N の場合、余った葉は直接処理装置へ
   - または、複数の経路を同じ処理装置へ（確率向上）

### 交差回避の工夫
1. **層状配置**：各レベルを水平に配置
2. **順序保持**：左の親の子は左側、右の親の子は右側
3. **適切な間隔**：x座標の間隔を十分に取る

### 疑似コード

```python
def build_maximum_separator_graph(N, M, K, separator_positions, processor_positions):
    """
    分別器を最大限使用するグラフを構築
    
    Returns:
        separator_config: 各分別器設置場所の設定 [separator_type, exit1, exit2]
        processor_assignment: 各処理装置設置場所に割り当てるごみ種類
        entry_point: 搬入口からの接続先
    """
    
    # 完全二分木の高さを計算
    height = ceil(log2(N))
    
    # 各レベルのノード数
    level_nodes = []
    for i in range(height):
        level_nodes.append(min(2**i, M - sum(level_nodes)))
    
    # 分別器の配置を決定（BFSの順序で）
    separator_assignment = []
    node_positions = []
    
    # レベルごとに配置
    current_level_start = 0
    for level in range(height):
        level_size = level_nodes[level]
        level_y = 5000 - (level + 1) * 1000  # 各レベルのy座標
        
        # x座標を均等配置
        if level_size > 0:
            x_step = 10000 / (level_size + 1)
            for i in range(level_size):
                x = (i + 1) * x_step
                # 最も近い分別器設置場所を選択
                best_pos = find_nearest_separator_position(x, level_y, separator_positions)
                separator_assignment.append(best_pos)
                node_positions.append((x, level_y))
    
    # 接続関係の構築
    connections = []
    for level in range(height - 1):
        level_start = sum(level_nodes[:level])
        level_end = sum(level_nodes[:level+1])
        next_level_start = level_end
        next_level_end = sum(level_nodes[:level+2])
        
        for i in range(level_start, level_end):
            # 左の子
            left_child = next_level_start + 2 * (i - level_start)
            if left_child < next_level_end:
                connections.append((i, left_child, True))  # True = exit1
            else:
                # 処理装置に直接接続
                connections.append((i, assign_processor(i, True), True))
            
            # 右の子
            right_child = next_level_start + 2 * (i - level_start) + 1
            if right_child < next_level_end:
                connections.append((i, right_child, False))  # False = exit2
            else:
                # 処理装置に直接接続
                connections.append((i, assign_processor(i, False), False))
    
    # 最下段から処理装置への接続
    last_level_start = sum(level_nodes[:-1])
    for i in range(last_level_start, len(separator_assignment)):
        # 各ノードから2つの処理装置へ
        processor1 = (2 * (i - last_level_start)) % N
        processor2 = (2 * (i - last_level_start) + 1) % N
        connections.append((i, processor1, True))
        connections.append((i, processor2, False))
    
    # 分別器の種類を選択（情報利得が最大のものを優先）
    separator_types = select_best_separators(connections, K, p_matrix)
    
    return separator_assignment, connections, separator_types

def select_best_separators(connections, K, p_matrix):
    """
    各位置に最適な分別器を選択
    """
    separator_types = []
    
    for node_id, connections_from_node in enumerate(connections):
        # このノードを通るごみの種類と確率を計算
        passing_waste = calculate_passing_waste(node_id)
        
        # 最も分離性能が高い分別器を選択
        best_separator = -1
        best_score = -1
        
        for k in range(K):
            # エントロピーまたは分離度を計算
            score = calculate_separation_score(passing_waste, p_matrix[k])
            if score > best_score:
                best_score = score
                best_separator = k
        
        separator_types.append(best_separator)
    
    return separator_types

def calculate_separation_score(waste_probs, separator_probs):
    """
    分別器の分離性能をスコア化
    エントロピーの減少量や、分散などで評価
    """
    exit1_probs = []
    exit2_probs = []
    
    for waste_type, prob in waste_probs:
        exit1_probs.append(prob * separator_probs[waste_type])
        exit2_probs.append(prob * (1 - separator_probs[waste_type]))
    
    # 出口1と出口2での分布の差を評価
    # 大きく分かれているほど良い
    entropy_before = calculate_entropy(waste_probs)
    entropy_exit1 = calculate_entropy(exit1_probs)
    entropy_exit2 = calculate_entropy(exit2_probs)
    
    # 情報利得
    info_gain = entropy_before - (sum(exit1_probs) * entropy_exit1 + 
                                  sum(exit2_probs) * entropy_exit2)
    
    return info_gain
```

### 最適化の追加考慮事項
1. **分別器の再利用**：同じ分別器を複数箇所で使用
2. **確率の偏り活用**：特定のごみを高確率で分離できる分別器を優先配置
3. **経路の冗長性**：重要なごみには複数経路を用意（確率向上）
4. **動的な木構造調整**：完全二分木でなく、不均衡な木も検討