<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cooperative Trash Sorting Visualizer</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 45%; height: 150px; }
    #controls { margin-top: 10px; }
    #canvas { border: 1px solid #ccc; margin-top: 10px; }
    #status { margin-top: 10px; font-weight: bold; }
  </style>
</head>
<body>
  <h2>Cooperative Trash Sorting Visualizer</h2>
  <div>
    <textarea id="input" placeholder="入力をここに貼り付け"></textarea>
    <textarea id="output" placeholder="出力をここに貼り付け"></textarea>
  </div>
  <div id="controls">
    <button id="load">ロード</button>
    <input type="range" id="slider" min="0" max="0" value="0" disabled>
  </div>
  <div id="status"></div>
  <canvas id="canvas" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let points = [];
    let turns = [];

    function pointInTriangle(pt, a, b, c) {
      const area = (p, q, r) => ((q.x-p.x)*(r.y-p.y) - (q.y-p.y)*(r.x-p.x));
      const A = area(a,b,c);
      const A1 = area(pt, b, c);
      const A2 = area(a, pt, c);
      const A3 = area(a, b, pt);
      return Math.sign(A) === Math.sign(A1) && Math.sign(A) === Math.sign(A2) && Math.sign(A) === Math.sign(A3);
    }

    document.getElementById('load').onclick = () => {
      points = [];
      turns = [];
      document.getElementById('status').textContent = '';
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const inText = document.getElementById('input').value.trim().split(/\s+/).map(Number);
      if (inText.length < 3) { alert('入力が不完全です'); return; }
      let idx = 0;
      const X = inText[idx++], Y = inText[idx++], Z = inText[idx++];
      const total = X+Y+Z;
      for (let i = 0; i < total; i++) {
        const x = inText[idx++], y = inText[idx++];
        const type = (i < X ? 0 : (i < X+Y ? 1 : 2));
        points.push({x,y,type,collector:null,turn:null});
      }

      const outText = document.getElementById('output').value.trim().split(/\s+/).map(Number);
      if (outText.length < 8) { alert('出力が不完全です'); return; }
      idx = 0;
      const init = [];
      for (let j=0;j<4;j++) init.push({x: outText[idx++], y: outText[idx++]});
      let moves = [];
      while (idx + 7 < outText.length) {
        const m = [];
        for (let j=0;j<4;j++) m.push({x: outText[idx++], y: outText[idx++]});
        moves.push(m);
      }

      let scoreT=0, scoreA=0;
      turns.push({p1:init[0], q1:init[1], p2:init[2], q2:init[3], scoreT, scoreA, remR: Z});
      for (let t=0; t<moves.length; t++) {
        const [p1n,q1n,p2n,q2n] = moves[t];
        points.forEach(p=>{
          if (p.collector===null && p.type===0) {
            if (pointInTriangle(p, turns[t].p1, turns[t].q1, p1n) ||
                pointInTriangle(p, p1n, turns[t].q1, q1n)) {
              p.collector = 'tak'; p.turn = t+1; scoreT++;
            }
          }
        });
        points.forEach(p=>{
          if (p.collector===null && p.type===1) {
            if (pointInTriangle(p, turns[t].p2, turns[t].q2, p2n) ||
                pointInTriangle(p, p2n, turns[t].q2, q2n)) {
              p.collector = 'aoki'; p.turn = t+1; scoreA++;
            }
          }
        });
        const remR = points.filter(p=>p.type===2 && p.collector===null).length;
        turns.push({p1:p1n, q1:q1n, p2:p2n, q2:q2n, scoreT, scoreA, remR});
      }

      const slider = document.getElementById('slider');
      slider.max = turns.length - 1;
      slider.value = 0;
      slider.disabled = false;
      slider.oninput = () => renderTurn(+slider.value);
      renderTurn(0);
    };

    function renderTurn(t) {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      const margin = 20;
      const scaleX = (w - 2*margin) / 1e6;
      const scaleY = (h - 2*margin) / 1e6;

      points.forEach(p=>{
        let color;
        if (p.collector==='tak' && p.turn <= t) {
          color = 'red';
        } else if (p.collector==='aoki' && p.turn <= t) {
          color = 'blue';
        } else {
          if (p.type === 0) {
            color = 'orange'; // 燃えるごみ
          } else if (p.type === 1) {
            color = 'brown'; // 燃えないごみ
          } else {
            color = 'green'; // 資源ごみ(残)
          }
        }
        const cx = margin + p.x * scaleX;
        const cy = h - (margin + p.y * scaleY);
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(cx, cy, 3, 0, 2*Math.PI); ctx.fill();
      });

      const turn = turns[t];
      [[turn.p1,turn.q1,'red'], [turn.p2,turn.q2,'blue']].forEach(([a,b,color])=>{
        ctx.strokeStyle = color; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(margin + a.x*scaleX, h - (margin + a.y*scaleY));
        ctx.lineTo(margin + b.x*scaleX, h - (margin + b.y*scaleY));
        ctx.stroke();
      });

      document.getElementById('status').textContent =
        `ターン ${t} / ${turns.length-1} — ` +
        `燃えるごみ: ${turn.scoreT} / ${points.filter(p=>p.type===0).length}, ` +
        `燃えないごみ: ${turn.scoreA} / ${points.filter(p=>p.type===1).length}, ` +
        `資源残: ${turn.remR}`;
    }
  </script>
</body>
</html>
